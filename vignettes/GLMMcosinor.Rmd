---
title: "GLMMcosinor"
author: "Oliver Jayasinghe and Rex Parsons"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{introduction-to-GLMMcosinor}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(GLMMcosinor)
library(dplyr)

testdata_simple <- simulate_cosinor(1000,
  n_period = 2,
  mesor = 5,
  amp = 2,
  acro = 1,
  beta.mesor = 4,
  beta.amp = 1,
  beta.acro = 0.5,
  family = "poisson",
  period = c(12),
  n_components = 1,
  beta.group = TRUE
)

testdata_two_components <- simulate_cosinor(1000,
  n_period = 10,
  mesor = 7,
  amp = c(0.1, 0.4),
  acro = c(1, 1.5),
  beta.mesor = 4.4,
  beta.amp = c(2, 1),
  beta.acro = c(1, -1.5),
  family = "poisson",
  period = c(12, 6),
  n_components = 2,
  beta.group = TRUE
)

testdata_multicomponent <- simulate_cosinor(1000,
  n_period = 10,
  mesor = 7,
  amp = c(0.1, 0.4, 0.5),
  acro = c(1, 1.5, 0.1),
  beta.mesor = 4.4,
  beta.amp = c(2, 1, 0.4),
  beta.acro = c(1, -1.5, -1),
  family = "poisson",
  period = c(12, 6, 12),
  n_components = 3,
  beta.group = TRUE
)
```

```{r srr, eval = FALSE, echo = FALSE}
#' @srrstats {G1.0} *Statistical Software should list at least one primary reference from published academic literature.*
#' @srrstats {G1.1} *Statistical Software should document whether the algorithm(s) it implements are:* - *The first implementation of a novel algorithm*; or - *The first implementation within **R** of an algorithm which has previously been implemented in other languages or contexts*; or - *An improvement on other implementations of similar algorithms in **R***.
#' @srrstats {G1.3} *All statistical terminology should be clarified and unambiguously defined.*
```

```{r, message=F, warning=F}
data(vitamind)
object <- cosinor.glmm(Y ~ X + amp_acro(time,
  n_components = 1, period = 12,
  group = "X"
), data = vitamind)

autoplot(object, superimpose.data = TRUE, x_str = "X", predict.ribbon = FALSE, data_opacity = 0.08)
```

## Introduction

The `{GLMMcosinor}` package allows the user to fit generalised linear
models based on circadian data, and allows users to summarise, predict,
and plot based on this modelling. Existing packages have focused
primarily on Gaussian data. Some circadian regression modelling packages
have allowed users to specify generalised linear models, but with
limited flexibility. GLMMcosinor takes a comprehensive approach to
modelling by utilising the glmmTMB package, which allows users to model
circadian data from a wide range of distributions (for full list - see
`?family` and `?glmmTMB::family_glmmTMB`) including:

-   Binomial
-   Guassian
-   Inverse Gaussian
-   Gamma
-   Poisson
-   Negative Binomial

The table below shows what features are available within GLMMcosinor and
other methods.

```{r, echo=FALSE, warning=FALSE, message=FALSE}
source("fixtures/methods-table.R")
dat
```

## `cosinor.glmm()`

`cosinor.glmm()` wrangles the data appropriately to fit the cosinor
model given the formula specified by the user. It provides estimates of
amplitude, acrophase, and MESOR (Midline Statistic Of Rhythm).

The formula argument for `cosinor.glmm()` is specified using the
`{lme4}` style (for details see `vignette("lmer", package = "lme4")`).
The only difference is that it allows for use of an `amp_acro()` call
within the formula that is used to identify the circadian components and
relevant variables in the `data.frame`. Any other combination of
covariates can also be included in the formula as well as random effects
and zero-inflation (`ziformula`) and dispersion (`dispformula`)
formulae. For detailed examples of how to specify models, see the
[mixed-models](https://rwparsons.github.io/GLMMcosinor/articles/mixed-models.html),
[model-specification](https://rwparsons.github.io/GLMMcosinor/articles/model-specification.html)
and
[multiple-components](https://rwparsons.github.io/GLMMcosinor/articles/multiple-components.html)
vignettes.

## An overview of the statistical methods used for parameter estimation

The `{GLMMcosinor}` package provides estimates of amplitude ($A$),
acrophase ($\phi$), and MESOR ($M$). In the single-component case, these
parameters correspond to the following regression model:

$$Y(t) = M + Acos(\frac{2\pi t}{\tau} + \phi) + e(t)$$ where $e(t)$ is
the error term.

This model can be equivalently expressed as a generalised linear model:

$$Y(t) = M + \beta x + \gamma z + e(t)$$

Where $x =cos(\frac{2\pi t}{τ}\times \pi)$,
$z =sin(\frac{2\pi t}{τ}\times \pi)$, $\beta = A cos(\phi)$,
$\gamma = -A sin(\phi)$

In our code, the `amp_acro()` function will modify the dataset supplied
in the `cosinor.glmm()` call by creating two transformed columns of
data: `rrr` and `sss` which take the role of $x$ and $z$ respectively
from the equation above. 'rrr' and 'sss' are treated as variables, and
the estimates of their coefficients are therefore $\hat\beta$ and
$\hat\gamma$. These estimates are what is presented in as 'Raw
Coefficients' in the output of the `cosinor.glmm()` function. Depending
on the model specification, an estimate for MESOR ('(Intercept)') may be
present and this does not need to be transformed. For this reason, the
MESOR terms will be the same in both the raw and transformed coefficient
tables in the output. But, to get the estimates for amplitude ($A$) and
acrophase ($\phi$), the estimates for $\hat\beta$ and $\hat\gamma$ must
be transformed as per the following equations:

$$\hat\phi = \arctan(\frac{-\hat\gamma}{\hat\beta}) $$

$$\hat A = (\hat\beta ^2 + \hat\gamma ^ 2) ^ \frac{1}{2} $$

These transformations are handled by the internal function
`get_new_coefs()` inside the `data_utils.R` script. The result of these
transformations is what is presented in the 'Transformed Coefficients'
table as part of the `cosinor.glmm()` output.

For example, consider the following model and its output:

```{r, message=F, warning=F}
data(vitamind)
cosinor.glmm(Y ~ X + amp_acro(time, period = 12, group = "X"), data = vitamind)

```

Notice how both the raw and transformed coefficients are provided as
output. Also, notice how the dataframe is modified to include
`main_rrr1` and `main_sss1` columns of data. This is the data that the
`glmmTMB()` function fits a regression model to:

```{r, message=F, warning=F}
head(object$newdata)
```

In this example, the `main` prefix indicates that this is the data for
the conditional model, as opposed to potential dispersion or
zero-inflation models which have the prefixes `disp` and `zi`
respectively. The numeric suffix 1 indicates that this is the data for
component 1. If there are multiple components, the columns of data will
be named accordingly. These naming conventions are consistent throughout
the `{GLMMcosinor}` package.

The transformations behind multi-component models follow the same
principles, and a more detailed discussion of this process in addition
to the other statistics used in this package can be found in
['Cosinor-based
rhythmometry'](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3991883)
(Cornelissen, 2014).

## A basic overview of `cosinor.glmm()`

The `cosinor.glmm()` function is used to fit cosinor models to a variety
of distributions using the `glmmTMB()` function.

```{r}

formula <- Y ~ amp_acro(time, period = 12)
data <- vitamind
family <- gaussian

cosinor.glmm(formula, data, family)
```

-   `formula`: A formula specifying the model structure, including the
    response variable and the cosinor components. The formula
    specification relies on the `amp_acro` function to handle the
    transformations. This formula is outlined below.
-   `data`: The dataset containing the variables used in the formula.
-   `family`: The family of the distribution for the response variable
    (e.g., poisson, gaussian, or any family found in`?family` and
    `?glmmTMB::family_glmmTMB`)

The `amp_acro()` function is used within the formula to specify the
cosinor components. It allows you to control the grouping structure,
rhythm period, and the number of components. The arguments of
`amp_acro()` include:

-   `group`: The name of the grouping variable in the dataset.
-   `time_col`: The name of the time column.
-   `n_components`: The number of components in the cosinor model.
-   `period`: The period(s) of the rhythm.

### Understanding the output

The most relevant output from the `cosinor.glmm()` function is likely to
be the parameter estimates for MESOR, amplitude, and acrophase under the
'Transformed Coefficients' heading. A detailed explanation of the
difference between the raw coefficients and the transformed coefficients
is found in this vignette, in the **'An overview of the statistical
methods used for parameter estimation'** section.

The following example looks at a grouped single-component model based on
a Gaussian distribution from the `vitamind` dataset.

```{r, message=F, warning=F}
data(vitamind)
cosinor.glmm(Y ~ X + amp_acro(time, period = 12, group = "X"), data = vitamind)
```

Under the 'Transformed Coefficients' heading:

-   `(Intercept) = 29.6898`is the MESOR estimate of group 0

-   `[X=1] = 1.90186` is the difference between the MESOR estimates of
    group 1 and 2 \*

-   `[X=0]:amp = 6.27046` is the amplitude estimate for group 0

-   `[X=1]:amp = 8.09947` is the amplitude estimate for group 1

-   `[X=0]:acr = 1.42181` is the acrophase estimate in radians for
    group 0 \*\*

-   `[X=1]:acr = 0.63715` is the acrophase estimate in radians for
    group 1

\* Hence, the MESOR estimate for group 1 would be
`29.6898 + 1.90186 = 31.59166`. This is due to the behaviour of the
`glmmTMB()` function. This can be adjusted by adding a `0 +` to the
beginning of the formula:

```{r, message=F, warning=F}
data(vitamind)
cosinor.glmm(Y ~ 0 + X + amp_acro(time, period = 12, group = "X"), data = vitamind)
```

Note how now, `[X=1] = 31.59165` and this represents the estimate for
the MESOR for group 1, rather than the difference.

\*\* Note how the acrophase is provided in units of radians. Since the period is 12, an acrophase of 1.42181 radians corresponds to a time of $\frac{1.42181}{2 \pi} \times 12 = 2.715457$. This means the maximum response occurs at 2.715 time units. We can check this visually using the `autoplot()` function, looking at the `[X=0]` level (red line)

```{r}
object <- cosinor.glmm(Y ~ 0 + X + amp_acro(time, period = 12, group = "X"), data = vitamind)
autoplot(object, predict.ribbon = FALSE)

```
## More advanced `cosinor.glmm()` model specification

The `cosinor.glmm()` function allows you to specify different types of
cosinor models with or without grouping variables. The function can also
generate dispersion models and zero-inflation models in addition to the
conditional model that is generated by default. For more detailed
explanations and examples, see the
[model-specification](https://rwparsons.github.io/GLMMcosinor/articles/model-specification.html)
article.

Additionally, the `cosinor.glmm()` function provides more advanced
functionalities for multi-component models, and detailed explanations
can be found in the
[multiple-components](https://rwparsons.github.io/GLMMcosinor/articles/multiple-components.html)
article.

The cosinor.glmm() function also allows mixed model specification. See
the
[mixed-models](https://rwparsons.github.io/GLMMcosinor/articles/mixed-models.html)
article for more details.

## Using `summary()`

The `summary()` method for `cosinor.glmm` objects provides a more
detailed summary of the model and its parameter estimates and
uncertainty. It outputs the estimates, standard errors, confidence
intervals, and p-values for both the raw model parameters and the
transformed parameters. The summary statistics do not represent a
comparison between any groups for the cosinor components - that is the
role of the `test_cosinor_components()` and `test_cosinor_levels()`
functions.

Here is an example of how to use `summary()`:

```{r, message=F, warning=F}
object <- cosinor.glmm(Y ~ group + amp_acro(times, period = 12, group = "group"), data = testdata_simple, family = poisson())
summary(object)
```

## Using `predict()`

The `predict()` method for `cosinor.glmm` objects allows users to get
predicted values from the model on either the existing or new data.
(These predicted values are used when generating the plots using
`plot()`.)

```{r, message=F, warning=F}
fit <- cosinor.glmm(Y ~ group + amp_acro(times, period = 12, group = NA), data = testdata_simple, family = poisson())
head(predict(fit))
```

## Plotting `cosinor.glmm` objects

The `{GLMMcosinor}` package includes two ways to visualise
`cosinor.glmm()` objects. Firstly, the `autoplot()` method creates a
time-response plot of the fitted model for all groups:

```{r, message=F, warning=F}
object <- cosinor.glmm(Y ~ group + amp_acro(times, period = 12, group = "group"), data = testdata_simple, family = poisson())

autoplot(object, superimpose.data = TRUE)
```

This function also allows users to superimpose the data (that was used
to fit the model) over the fitted model, using the
`superimpose.data = TRUE`, as demonstrated above. By default, the
generated plot will have x-limits corresponding to the minimum and
maximum values of the time-vector in the original dataframe, although
the x-limits can be manually defined by the user using the `xlims`
argument. The details of using the `autoplot` function are found in the
[model-visualisations](https://rwparsons.github.io/GLMMcosinor/articles/model-visualisations.html)
vignette.

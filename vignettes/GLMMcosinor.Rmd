---
title: "GLMMcosinor"
author: "Oliver Jayasinghe and Rex Parsons"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{introduction-to-GLMMcosinor}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(GLMMcosinor)
library(dplyr)
withr::with_seed(
  50,
  {
    testdata_simple <- simulate_cosinor(1000,
      n_period = 2,
      mesor = 5,
      amp = 2,
      acro = 1,
      beta.mesor = 4,
      beta.amp = 1,
      beta.acro = 0.5,
      family = "poisson",
      period = c(12),
      n_components = 1,
      beta.group = TRUE
    )

    testdata_two_components <- simulate_cosinor(1000,
      n_period = 10,
      mesor = 7,
      amp = c(0.1, 0.4),
      acro = c(1, 1.5),
      beta.mesor = 4.4,
      beta.amp = c(2, 1),
      beta.acro = c(1, -1.5),
      family = "poisson",
      period = c(12, 6),
      n_components = 2,
      beta.group = TRUE
    )

    testdata_multicomponent <- simulate_cosinor(1000,
      n_period = 10,
      mesor = 7,
      amp = c(0.1, 0.4, 0.5),
      acro = c(1, 1.5, 0.1),
      beta.mesor = 4.4,
      beta.amp = c(2, 1, 0.4),
      beta.acro = c(1, -1.5, -1),
      family = "poisson",
      period = c(12, 6, 12),
      n_components = 3,
      beta.group = TRUE
    )
  }
)
```

```{r srr, eval = FALSE, echo = FALSE}
#' @srrstats {G1.0}
#' @srrstats {G1.1}
#' @srrstats {G1.3}
```

```{r, message=F, warning=F}
data(vitamind)
object <- cosinor.glmm(Y ~ X + amp_acro(time,
  n_components = 1, period = 12,
  group = "X"
), data = vitamind)

autoplot(object,
  superimpose.data = TRUE,
  x_str = "X",
  predict.ribbon = FALSE,
  data_opacity = 0.2
)
```

## Introduction

The `{GLMMcosinor}` package allows the user to fit generalised linear
models based on circadian data, and allows users to summarise, predict,
and plot based on this modelling. Existing packages have focused
primarily on Gaussian data. Some circadian regression modelling packages
have allowed users to specify generalised linear models, but with
limited flexibility. GLMMcosinor takes a comprehensive approach to
modelling by utilising the glmmTMB package, which allows users to model
circadian data from a wide range of distributions (for full list - see
`?family` and `?glmmTMB::family_glmmTMB`) including:

-   Binomial
-   Guassian
-   Inverse Gaussian
-   Gamma
-   Poisson
-   Negative Binomial

The table below shows what features are available within GLMMcosinor and
other methods.

```{r, echo=FALSE, warning=FALSE, message=FALSE}
source("fixtures/methods-table.R")
dat
```

## `cosinor.glmm()`

`cosinor.glmm()` wrangles the data appropriately to fit the cosinor
model given the formula specified by the user. It provides estimates of
amplitude, acrophase, and MESOR (Midline Statistic Of Rhythm).

The formula argument for `cosinor.glmm()` is specified using the
`{lme4}` style (for details see `vignette("lmer", package = "lme4")`).
The only difference is that it allows for use of an `amp_acro()` call
within the formula that is used to identify the circadian components and
relevant variables in the `data.frame`. Any other combination of
covariates can also be included in the formula as well as random effects
and zero-inflation (`ziformula`) and dispersion (`dispformula`)
formulae. For detailed examples of how to specify models, see the
[mixed-models](https://rwparsons.github.io/GLMMcosinor/articles/mixed-models.html),
[model-specification](https://rwparsons.github.io/GLMMcosinor/articles/model-specification.html)
and
[multiple-components](https://rwparsons.github.io/GLMMcosinor/articles/multiple-components.html)
vignettes.

## An overview of the statistical methods used for parameter estimation

The `{GLMMcosinor}` package provides estimates of amplitude ($A$),
acrophase ($\phi$), and MESOR ($M$).

-   MESOR ($M$) is the Midline Estimating Statistic of Rhythm, and may
    also be referred to as the equilbrium point

-   Amplitude ($A$) is the difference between the MESOR and the maximal
    response

-   Acrophase ($\phi$) is the phase at which the maximal response
    occurs.

These parameters form the single-component cosinor model:

$$Y(t) = M + Acos(\frac{2\pi t}{\tau} - \phi) + e(t)$$ where $e(t)$ is
the error term.

This model can be equivalently expressed as a generalised linear model:

$$Y(t) = M + \beta x + \gamma z + e(t)$$

Where $x =cos(\frac{2\pi t}{τ})$, $z =sin(\frac{2\pi t}{τ})$,
$\beta = A cos(\phi)$, $\gamma = A sin(\phi)$

In the `GLMMcosinor` package, the `amp_acro()` function will modify the
dataset supplied in the `cosinor.glmm()` call by creating two
transformed columns of data: `rrr` and `sss` which take the role of $x$
and $z$ respectively from the equation above. 'rrr' and 'sss' are
treated as variables, and the estimates of their coefficients are
therefore $\hat\beta$ and $\hat\gamma$. These estimates are what is
presented in as 'Raw Coefficients' in the output of the `cosinor.glmm()`
function. Depending on the model specification, an estimate for MESOR
('(Intercept)') may be present and this does not need to be transformed.
For this reason, the MESOR terms will be the same in both the raw and
transformed coefficient tables in the output. But, to get the estimates
for amplitude ($A$) and acrophase ($\phi$), the estimates for
$\hat\beta$ and $\hat\gamma$ must be transformed as per the following
equations:

$$\hat\phi = \arctan(\frac{\hat\gamma}{\hat\beta}) $$

$$\hat A = \sqrt{\hat\beta ^2 + \hat\gamma ^ 2}$$

For example, consider the following model and its output:

```{r, message=F, warning=F}
data(vitamind)
cosinor.glmm(Y ~ X + amp_acro(time, period = 12, group = "X"), data = vitamind)
```

Notice how both the raw and transformed coefficients are provided as
output. Also, notice how the dataframe is modified to include
`main_rrr1` and `main_sss1` columns of data. This is the data that the
`glmmTMB()` function fits a regression model to:

```{r, message=F, warning=F}
head(object$newdata)
```

In this example, the `main` prefix indicates that this is the data for
the conditional model, as opposed to potential dispersion or
zero-inflation models which have the prefixes `disp` and `zi`
respectively. The numeric suffix 1 indicates that this is the data for
component 1. If there are multiple components, the columns of data will
be named accordingly. These naming conventions are consistent throughout
the `{GLMMcosinor}` package.

The transformations behind multi-component models follow the same
principles, and a more detailed discussion of this process in addition
to the other statistics used in this package can be found in
['Cosinor-based
rhythmometry'](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3991883)
(Cornelissen, 2014).

## A basic overview of `cosinor.glmm()`

The `cosinor.glmm()` function is used to fit cosinor models to a variety
of distributions using the `glmmTMB()` function.

```{r}
formula <- Y ~ amp_acro(time, period = 12)
data <- vitamind
family <- gaussian

cosinor.glmm(formula, data, family)
```

-   `formula`: A formula specifying the model structure, including the
    response variable and the cosinor components. The formula
    specification relies on the `amp_acro` function to handle the
    transformations. This formula is outlined below.
-   `data`: The dataset containing the variables used in the formula.
-   `family`: The family of the distribution for the response variable
    (e.g., poisson, gaussian, or any family found in`?family` and
    `?glmmTMB::family_glmmTMB`)

The `amp_acro()` function is used within the formula to specify the
cosinor components. It allows you to control the grouping structure,
rhythm period, and the number of components. The arguments of
`amp_acro()` include:

-   `group`: The name of the grouping variable in the dataset.
-   `time_col`: The name of the time column.
-   `n_components`: The number of components in the cosinor model.
-   `period`: The period(s) of the rhythm.

### Understanding the output

The most relevant output from the `cosinor.glmm()` function is likely to
be the parameter estimates for MESOR, amplitude, and acrophase under the
'Transformed Coefficients' heading. A detailed explanation of the
difference between the raw coefficients and the transformed coefficients
is found in this vignette, in the section titled **'An overview of the
statistical methods used for parameter estimation'**.

The following example looks at a grouped single-component model based on
a Gaussian distribution from the `vitamind` dataset.

```{r, message=F, warning=F}
data(vitamind)
cosinor.glmm(Y ~ X + amp_acro(time, period = 12, group = "X"), data = vitamind)
```

Under the 'Transformed Coefficients' heading:

-   `(Intercept) = 29.6898`is the MESOR estimate of group 0

-   `[X=1] = 1.90186` is the difference between the MESOR estimates of
    group 1 and 2 \*

-   `[X=0]:amp = 6.27046` is the amplitude estimate for group 0

-   `[X=1]:amp = 8.09947` is the amplitude estimate for group 1

-   `[X=0]:acr = 1.42181` is the acrophase estimate in radians for group
    0 \*\*

-   `[X=1]:acr = 0.63715` is the acrophase estimate in radians for group
    1

\* Hence, the MESOR estimate for group 1 would be
`29.6898 + 1.90186 = 31.59166`. This is due to the behaviour of the
`glmmTMB()` function. This can be adjusted by adding a `0 +` to the
beginning of the formula:

```{r, message=F, warning=F}
data(vitamind)
cosinor.glmm(
  Y ~ 0 + X + amp_acro(time,
    period = 12,
    group = "X"
  ),
  data = vitamind
)
```

Note how now, `[X=1] = 31.59165` and this represents the estimate for
the MESOR for group 1, rather than the difference.

\*\* Note how the acrophase is provided in units of radians. Since the
period is 12, an acrophase of 1.42181 radians corresponds to a time of
$\frac{1.42181}{2 \pi} \times 12 = 2.715457$. This means the maximum
response occurs at 2.715 time units. We can check this visually using
the `autoplot()` function, looking at the `[X=0]` level (red line)

```{r}
object <- cosinor.glmm(
  Y ~ 0 + X + amp_acro(time,
    period = 12,
    group = "X"
  ),
  data = vitamind
)
autoplot(object, predict.ribbon = FALSE)
```

## More advanced `cosinor.glmm()` model specification

The `cosinor.glmm()` function allows you to specify different types of
cosinor models with or without grouping variables. The function can also
generate dispersion models and zero-inflation models in addition to the
conditional model that is generated by default. For more detailed
explanations and examples, see the
[model-specification](https://rwparsons.github.io/GLMMcosinor/articles/model-specification.html)
article.

Additionally, the `cosinor.glmm()` function provides more advanced
functionalities for multi-component models, and detailed explanations
can be found in the
[multiple-components](https://rwparsons.github.io/GLMMcosinor/articles/multiple-components.html)
article.

The cosinor.glmm() function also allows mixed model specification. See
the
[mixed-models](https://rwparsons.github.io/GLMMcosinor/articles/mixed-models.html)
article for more details.

## Using `summary()` and testing for differences between estimates

The `summary()` method for `cosinor.glmm` objects provides a more
detailed summary of the model and its parameter estimates and
uncertainty. It outputs the estimates, standard errors, confidence
intervals, and p-values for both the raw model parameters and the
transformed parameters. The summary statistics do not represent a
comparison between any groups for the cosinor components - that is the
role of the `test_cosinor_components()` and `test_cosinor_levels()`
functions.

Here is an example of how to use `summary()`:

```{r, message=F, warning=F}
object <- cosinor.glmm(Y ~ group + amp_acro(times, 
                                            period = 12, 
                                            group = "group"),
  data = testdata_simple, family = poisson()
)
summary(object)
```

If we wanted to test the difference between the amplitude estimate for
component 1 between `group 1` and `group 2`, we can use the
`test_cosinor_levels()` function:

```{r}
test_cosinor_levels(object, x_str = "group", param = "amp")
```

The estimate here is the estimate of the difference between the inputted
values, along with its confidence interval. The real parameters for
`amp` in the first component were 2 and 1 for groups 0 and 1
respectively, and so the difference is approximately -1.

Now, consider an example where the difference is not so clear.

```{r}
withr::with_seed(
  50,
  {
    testdata_summary <- simulate_cosinor(100,
      n_period = 10,
      mesor = 7,
      amp = c(0.1, 0.5),
      acro = c(1, 1),
      beta.mesor = 4.4,
      beta.amp = c(0.1, 0.46),
      beta.acro = c(0.5, -1.5),
      family = "poisson",
      period = c(12, 6),
      n_components = 2,
      beta.group = TRUE
    )
  }
)
object <- cosinor.glmm(
  Y ~ group + amp_acro(times,
    period = c(12, 6),
    n_components = 2,
    group = "group"
  ),
  data = testdata_summary,
  family = poisson()
)
test_cosinor_levels(object, x_str = "group", param = "amp", component_index = 1)
```

In this example, there is no significant difference in the estimate of
`amp` for the first component between the reference group and the
comparator group. Also notice how if we are comparing between levels, we
should keep the component the same, and that is what `component_index`
sets. Likewise, when we test between components using
`test_cosinor_components()`, we can indicate which level this comparison
occurs using `level_index`. Furthermore, there may be multiple `groups`,
in which case we can fix the `group` using the `x_str` argument.

As an example of testing the difference between components for the same
level:

```{r}
test_cosinor_components(object, x_str = "group", param = "acr", level_index = 1)
```

In this situation, there is a significant difference between the
acrophase for the comparator group between its two components.

## Using `predict()`

The `predict()` method for `cosinor.glmm` objects allows users to get
predicted values from the model on either the existing or new data.
(These predicted values are used when generating the plots using
`plot()`.)

```{r, message=F, warning=F}
fit <- cosinor.glmm(
  Y ~ group + amp_acro(times,
    period = 12,
    group = NA
  ),
  data = testdata_simple,
  family = poisson()
)
head(predict(fit))
```

## Plotting `cosinor.glmm` objects

The `{GLMMcosinor}` package includes two ways to visualise
`cosinor.glmm()` objects. Firstly, the `autoplot()` method creates a
time-response plot of the fitted model for all groups:

```{r, message=F, warning=F}
object <- cosinor.glmm(
  Y ~ group + amp_acro(times,
    period = 12,
    group = "group"
  ),
  data = testdata_simple,
  family = poisson()
)

autoplot(object, superimpose.data = TRUE)
```

This function also allows users to superimpose the data (that was used
to fit the model) over the fitted model, using the
`superimpose.data = TRUE`, as demonstrated above. By default, the
generated plot will have x-limits corresponding to the minimum and
maximum values of the time-vector in the original dataframe, although
the x-limits can be manually defined by the user using the `xlims`
argument. The details of using the `autoplot` function are found in the
[model-visualisations](https://rwparsons.github.io/GLMMcosinor/articles/model-visualisations.html)
vignette.
